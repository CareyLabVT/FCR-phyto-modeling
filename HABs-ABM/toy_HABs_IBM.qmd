---
title: "example_IBM"
author: "Brad Duthie"
format: html
editor: visual
---

## Source of tutorial

The example code below is pulled from <https://bradduthie.github.io/blog/individual-based-models-in-r/>.

## Modification workflow

1.  Random movement in one dimension of individuals seeded from a simulated depth profile, with a "sticky" upper/lower boundary
    1.  Eliminate x-dimension - check

    2.  Individuals move in increments of 0.1 m - check

    3.  Create "sticky" boundaries (individuals who move past the boundary are put back at the edge) - check

    4.  Seed individuals based on a depth profile from 0-9.3 m in 0.1 m increments, using an actual FP profile as a starting point - check

    5.  Eliminate birth and death for now and predators altogether - check

    6.  Alter plot so that you can see how individuals are moving over depth/time - check
2.  Movement of individuals given static water temp profile using turbulence/diffusion equation
    1.  Create a new dataframe for environmental conditions that can be referenced during model run (columns for now are depth, water temperature); start w/ constant water temperature so can see if phytos move towards constant distribution across depth over time - check

    2.  Figure out what other environmental conditions/traits need to be specified to provide all the correct information to eq. 9 of Hassan Ranjbar, Hamilton, et al. - check

        1.  cell density: \~950 kg m-3 for buoyant cyanos; \~1100 kg m-3 for diatoms (reference Reynolds 2006)

        2.  cell diameter: in meters; thinking somewhere in 10-20 um for FCR since cells usually small

        3.  cell shape: use 1 as a starting point (assuming spherical shape)

    3.  Add necessary environmental conditions/traits to environmental dataframe and inds, respectively

        1.  need to calculate dynamic (absolute) viscosity of water; use Korson et al. 1969

        2.  what eq to use to calculate water density from temperature? think might assume pure water for now and use Kell equation (Kell, 1975), then can go from there

    4.  Edit "movement" function to use eq. 9 instead of random movement

        1.  first, just incorporate buoyancy/sinking rate term and make sure phytos are behaving as expected

        2.  next, worry about random walk to simulate turbulent transport

```{r}
# =============================================================================
# Load packages
# =============================================================================
library(tidyverse)

# =============================================================================
# Movement function
# =============================================================================
movement <- function(inds, yloc = 2, ymax = 9.3){
  
    cell_diam <- inds[,3] # Get the cell diameters of all individuals
    cell_dens <- inds[,4] # Get the cell diameters of all individuals
    cell_shape <- inds[,5] # Get the cell diameters of all individuals

    dens <- (999.83952 + 16.945176*env[,1] - 0.0079870401*env[,1]^2 - 0.000046170461*env[,1]^3 + 0.00000010556302*env[,1]^4 - 0.00000000028054253*env[,1]^5) / (1 + 0.016879850*env[,1]) #Kell equation for water density (Kell, 1975)
    visc <- 10^(20 - env[,1])/(env[,1] + 96)*(1.2364 - 0.00137*(20 - env[,1]) + 0.0000057*(20 - env[,1])^2) #this actually calculates the ratio of viscosity at target temp/viscosity at 20 degrees C, but viscosity at 20 degrees C is ~ 1
    w_s <- (9.8081*cell_diam^2*(dens - cell_dens))/(18*cell_shape*visc) # Define the velocity given cell diameter
    y_move       <- w_s*60*60 # Calculate total distance moved over an hour
    inds[, yloc] <- inds[, yloc] + y_move;
    # =========   The reflecting boundary is added below
    for(i in 1:total_inds){ 
        if(inds[i, yloc] > ymax){         # If it moved past the maximum depth
            inds[i, yloc] <- ymax;        # Then move it back to the maximum depth
        }
        if(inds[i, yloc] < 0.1){            # If it moved below 0.1 (above surface)
            inds[i, yloc] <- 0.1;           # Then move it back to 0.1 (surface)
        }
    } 
    # =========  Now all individuals should stay on the landscape
    return(inds);
}

# =============================================================================
# Birth function
# =============================================================================
birth <- function(inds, lambda = 0.5, repr_col = 4){
    total_inds       <- dim(inds)[1]; # Get the number of individuals in inds
    ind_cols         <- dim(inds)[2]; # Total inds columns
    inds[, repr_col] <- rpois(n = total_inds, lambda = lambda); 
    total_off        <- sum(inds[, repr_col]);
    # ---- We now have the total number of new offspring; now add to inds
    new_inds     <- array(data = 0, dim = c(total_off, ind_cols));
    new_inds[,1] <- rnorm(n = dim(new_inds)[1], mean = 23, sd = 3);
    new_inds[,2] <- sample(x = 1:8, size = dim(new_inds)[1], replace = TRUE);
    new_inds[,3] <- sample(x = 1:8, size = dim(new_inds)[1], replace = TRUE);
    # ---- Our new offspring can now be attached in the inds array
    inds <- rbind(inds, new_inds);
    return(inds);
}

# =============================================================================
# Death function
# =============================================================================
death <- function(inds, xlen = 8, ylen = 8, dcol = 5, xcol = 2, ycol = 3){
    for(xdim in 1:xlen){      # For each row `xdim` of the landscape...
        for(ydim in 1:ylen){  # For each col `ydim` of the landscape...
            # Get the total number of individuals on the landscape cell
            on_cell <- sum( inds[, xcol] == xdim & inds[, ycol]  == ydim);
            # Only do something if on_cell is more than one
            if(on_cell > 1){
                # Get all of the occupants on the cell
                occupants <- which(inds[, xcol] == xdim & inds[, ycol] == ydim);
                # Sample all but one random occupants to die
                rand_occ  <- sample(x = occupants, size = on_cell - 1);
                # Then add their death to the last column of inds
                inds[rand_occ, dcol] <- 1;
            }
        }
    }
    return(inds);
}

# =============================================================================
# Simulate phytoplankton dynamics
# =============================================================================
# ----- Initialise individuals (phytos)
# TMRW: pick back up here
# Pull in an example FP profile
fp <- read_csv("./data/FluoroProbe_2018-08-02_FCR_50.csv")

# Create inds by looping through each depth increment and then creating that number of individuals at that depth based on ug/L
depths <- seq(from = 0.1, to = 9.3, by = 0.1)

inds <- NULL

for(i in 1:length(depths)){
  temp <- fp[i,]
  
  temp.df <- array(data = 0, dim = c(round(temp$TotalConcNoMixed_ugL,0),5))
  temp.df[,1] <- 1 #placeholder for taxon ID or some other trait
  temp.df[,2] <- depths[i]

  inds <- rbind(inds, temp.df)
}

#create cell diameter trait
mean_diam = 0.000015 # 15 um in meters
sd_diam = 0.000005 # 5 um in meters
inds[,3] <- rnorm(dim(inds)[1], mean = mean_diam, sd = sd_diam)

#create cell density trait
mean_dens = 1050 # In range for chlorophytes
sd_dens = 12 # To make sure they all sink
inds[,4] <- rnorm(dim(inds)[1], mean_dens, sd_dens)

#create cell shape trait
inds[,5] <- 1 # make them all spherical for now

colnames(inds) <- c("PFG","yloc","cell_diam","cell_dens","cell_shape")

# ----- Initialise environment (water temperature)

env <- array(data = 0, dim = c(length(depths),2))
  env[,1] <- 10 #water temperature; constant for now
  env[,2] <- depths
colnames(env) <- c("wt","yloc")

# ---- Start the simulation as before
ts         <- 0;
time_steps <- 40;
inds_hist  <- NULL;
while(ts < time_steps){
    inds            <- movement(inds); 
    #inds            <- birth(inds, lambda = 1.5);
    #inds            <- death(inds);
    #inds            <- inds[inds[, 5] == 0,]; # Retain living
    ts              <- ts + 1; 
    inds_hist[[ts]] <- inds;
}

# =============================================================================
# Print the results
# =============================================================================
ind_yloc <- array(data = NA, dim = c(40,length(depths)+1));
colnames(ind_yloc) <- c("timestep",depths)
for(i in 1:40){
  for(j in 1:length(depths)){
    ind_yloc[i, 1] <- i;                      # Save the time step
    ind_yloc[i, j+1] <- length(inds_hist[[i]][which(inds_hist[[i]][,2] == depths[j]),1]); # Save the number of individuals at each depth
  }
}
print(ind_yloc);

# =============================================================================
# Plot the results
# =============================================================================
plot_yloc <- data.frame(ind_yloc) %>%
  gather(X0.1:X9.3, key = "Depth_m",value = "ugL") %>%
  mutate(Depth_m = as.double(substring(Depth_m, 2)))
head(plot_yloc)

ggplot(data = plot_yloc, aes(x = ugL, y = Depth_m, group = timestep, color = timestep))+
  geom_path()+
  scale_y_reverse()+
  theme_classic()
```
